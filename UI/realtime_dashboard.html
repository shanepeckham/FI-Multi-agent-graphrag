<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Team Real-time Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto auto;
            gap: 20px;
            min-height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .status-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            height: fit-content;
        }

        .visualization-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            display: flex;
            flex-direction: column;
        }

        .final-output-panel {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            display: flex;
            flex-direction: column;
        }

        .activity-log {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-height: 300px;
            overflow-y: auto;
        }

        h1, h2, h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #27ae60;
        }

        .agent-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #3498db;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .agent-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .agent-card.active {
            border-left-color: #27ae60;
            background: #e8f5e8;
        }

        .agent-card.working {
            border-left-color: #f39c12;
            background: #fef9e7;
            animation: working 1.5s infinite;
        }

        .task-item {
            background: #fff;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #9b59b6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .task-item.completed {
            border-left-color: #27ae60;
            background: #f0f8f0;
        }

        .task-item.in-progress {
            border-left-color: #f39c12;
            background: #fefcf0;
        }

        .log-entry {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            font-size: 0.8em;
            color: #7f8c8d;
            min-width: 80px;
        }

        .log-type {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .log-type.agent {
            background: #3498db;
            color: white;
        }

        .log-type.task {
            background: #9b59b6;
            color: white;
        }

        .log-type.team {
            background: #27ae60;
            color: white;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes working {
            0% { background: #fef9e7; }
            50% { background: #fcf3cf; }
            100% { background: #fef9e7; }
        }

        .scrollable {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Custom scrollbar */
        .scrollable::-webkit-scrollbar {
            width: 6px;
        }

        .scrollable::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Query Interface Styles */
        .query-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e1e8ed;
        }

        .query-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-row.options-row {
            flex-direction: row;
            align-items: center;
        }

        .form-row label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }

        .form-row input[type="text"],
        .form-row input[type="password"],
        .form-row input[type="number"],
        .form-row textarea,
        .form-row select {
            padding: 10px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 0.9em;
            transition: border-color 0.3s ease;
        }

        .form-row input:focus,
        .form-row textarea:focus,
        .form-row select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-row textarea {
            resize: vertical;
            font-family: inherit;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 5px;
        }

        .form-row:has(.form-group) {
            flex-direction: row;
            gap: 15px;
        }

        .checkbox-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            margin: 0;
        }

        .submit-btn, .cancel-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-btn {
            background: #27ae60;
            color: white;
        }

        .submit-btn:hover {
            background: #2ecc71;
            transform: translateY(-1px);
        }

        .submit-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .cancel-btn {
            background: #e74c3c;
            color: white;
            margin-left: 10px;
        }

        .cancel-btn:hover {
            background: #c0392b;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .progress-bar {
            width: 200px;
            height: 6px;
            background: #ecf0f1;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            animation: progress-animation 2s infinite;
        }

        @keyframes progress-animation {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 0.9em;
            color: #7f8c8d;
            white-space: nowrap;
        }

        /* Query Response Section */
        .query-response-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e1e8ed;
            min-height: 300px;
        }

        .response-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
        }

        .response-content h1, .response-content h2, .response-content h3 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        .response-content h1 { font-size: 1.5em; }
        .response-content h2 { font-size: 1.3em; }
        .response-content h3 { font-size: 1.1em; }

        .response-content strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .response-content em {
            color: #5d6d7e;
            font-style: italic;
        }

        .response-content code {
            background: #f1c40f;
            color: #2c3e50;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .response-content pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .response-content ul, .response-content ol {
            margin: 10px 0;
            padding-left: 30px;
        }

        .response-content li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 Agent Team Real-time Visualization</h1>
            <div class="connection-status">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
                <span id="sessionInfo"></span>
            </div>
        </div>

        <!-- Query Interface Panel -->
        <div class="query-panel">
            <h3>📝 Query Interface</h3>
            <form id="queryForm" class="query-form">
                <div class="form-row">
                    <label for="endpoint">API Endpoint:</label>
                    <input type="text" id="endpoint" value="http://0.0.0.0:8000/query_team" placeholder="API endpoint URL">
                </div>
                
                <div class="form-row">
                    <label for="bearerToken">Bearer Token:</label>
                    <input type="password" id="bearerToken" placeholder="Optional authentication token">
                </div>
                
                <div class="form-row">
                    <label for="queryText">Query:</label>
                    <textarea id="queryText" rows="3" placeholder="Enter your query here...">What will the revenue in 2030 be?</textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="graphQueryType">Graph Query Type:</label>
                        <select id="graphQueryType">
                            <option value="local" selected>Local</option>
                            <option value="drift">Drift</option>
                            <option value="global">Global</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="searchQueryType">Search Query Type:</label>
                        <select id="searchQueryType">
                            <option value="SIMPLE" selected>Simple</option>
                            <option value="SEMANTIC">Semantic</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="timeoutMinutes">Timeout (min):</label>
                        <input type="number" id="timeoutMinutes" value="10" min="1" max="60">
                    </div>
                </div>
                
                <div class="form-row options-row">
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="useSearch" checked> Use Search</label>
                        <label><input type="checkbox" id="useGraph" checked> Use Graph</label>
                        <label><input type="checkbox" id="useWeb"> Use Web</label>
                        <label><input type="checkbox" id="useReasoning"> Use Reasoning</label>
                    </div>
                </div>
                
                <div class="form-row">
                    <button type="submit" id="submitQuery" class="submit-btn">Submit Query</button>
                    <button type="button" id="cancelQuery" class="cancel-btn" style="display: none;">Cancel</button>
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar" style="display: none;"></div>
                        <span class="progress-text" id="progressText"></span>
                    </div>
                </div>
            </form>
        </div>

        <!-- Query Response Panel -->
        <div class="query-response-panel">
            <h3>📋 Query Response</h3>
            <div class="response-content" id="queryResponse">
                <div style="text-align: center; color: #666; padding: 40px;">
                    No query submitted yet. Use the form above to start a query and see real-time progress below.
                </div>
            </div>
        </div>

        <div class="status-panel">
            <h3>📊 Team Status</h3>
            <div id="teamMetrics" class="metrics">
                <div class="metric">
                    <div class="metric-value" id="activeAgents">0</div>
                    <div class="metric-label">Active Agents</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="completedTasks">0</div>
                    <div class="metric-label">Completed Tasks</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="pendingTasks">0</div>
                    <div class="metric-label">Pending Tasks</div>
                </div>
            </div>

            <h3 style="margin-top: 25px;">🤖 Agents</h3>
            <div id="agentsList" class="scrollable"></div>
        </div>

        <div class="visualization-panel">
            <h3>📋 Current Tasks</h3>
            <div id="tasksList" class="scrollable"></div>
        </div>

        <div class="final-output-panel">
            <h3>🎯 Final Output</h3>
            <div id="finalOutputSection" class="scrollable">
                <div style="text-align: center; color: #666; padding: 20px;">
                    No final output yet
                </div>
            </div>
        </div>

        <div class="activity-log">
            <h3>📝 Activity Log</h3>
            <div id="activityLog" class="scrollable"></div>
        </div>
    </div>

    <script>
        class AgentTeamVisualizer {
            constructor() {
                this.socket = null;
                this.sessionId = this.generateSessionId();
                this.agents = new Map();
                this.tasks = new Map();
                this.activityLog = [];
                this.finalOutputs = [];
                this.currentRequest = null;
                this.requestCancelled = false;
                this.requestStartTime = null;
                this.metrics = {
                    activeAgents: 0,
                    completedTasks: 0,
                    pendingTasks: 0
                };
                
                this.connect();
                this.setupUI();
                this.setupQueryInterface();
            }

            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/${this.sessionId}`;
                
                this.socket = new WebSocket(wsUrl);
                
                this.socket.onopen = () => {
                    console.log('WebSocket connected');
                    this.updateConnectionStatus(true);
                };
                
                this.socket.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
                
                this.socket.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.updateConnectionStatus(false);
                    
                    // Attempt to reconnect after 3 seconds
                    setTimeout(() => {
                        if (this.socket.readyState === WebSocket.CLOSED) {
                            this.connect();
                        }
                    }, 3000);
                };
                
                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };
            }

            handleMessage(message) {
                console.log('Received message:', message);
                
                switch (message.type) {
                    case 'connection':
                        this.handleConnection(message);
                        break;
                    case 'agent_event':
                        this.handleAgentEvent(message);
                        break;
                    case 'task_event':
                        this.handleTaskEvent(message);
                        break;
                    case 'team_event':
                        this.handleTeamEvent(message);
                        break;
                    case 'progress':
                        this.handleProgress(message);
                        break;
                }
                
                this.addToActivityLog(message);
                this.updateMetrics();
            }

            handleConnection(message) {
                document.getElementById('sessionInfo').textContent = `Session: ${message.session_id}`;
            }

            handleAgentEvent(message) {
                const { event_type, data } = message;
                
                switch (event_type) {
                    case 'agent_created':
                        this.agents.set(data.agent_name, {
                            name: data.agent_name,
                            status: 'idle',
                            model: data.model || 'Unknown',
                            instructions: data.instructions || '',
                            current_task: null
                        });
                        break;
                    case 'agent_started_task':
                        if (this.agents.has(data.agent_name)) {
                            this.agents.get(data.agent_name).status = 'working';
                            this.agents.get(data.agent_name).current_task = data.task_description;
                        }
                        break;
                    case 'agent_completed_task':
                        if (this.agents.has(data.agent_name)) {
                            this.agents.get(data.agent_name).status = 'idle';
                            this.agents.get(data.agent_name).current_task = null;
                        }
                        break;
                }
                
                this.updateAgentsList();
            }

            handleTaskEvent(message) {
                const { event_type, data } = message;
                
                switch (event_type) {
                    case 'task_created':
                    case 'message_sent':
                        const taskId = data.task_id || data.message_id || Date.now();
                        this.tasks.set(taskId, {
                            id: taskId,
                            description: data.task_description || data.message || data.content,
                            recipient: data.recipient || data.to,
                            requestor: data.requestor || data.from,
                            status: 'pending',
                            created_at: message.timestamp,
                            message: data.message || data.content,
                            full_content: data
                        });
                        break;
                    case 'task_started':
                    case 'message_processing':
                        const startedTaskId = data.task_id || data.message_id || this.findTaskByDescription(data.task_description || data.message);
                        if (this.tasks.has(startedTaskId)) {
                            this.tasks.get(startedTaskId).status = 'in-progress';
                        } else {
                            // Create task if it doesn't exist
                            this.tasks.set(startedTaskId, {
                                id: startedTaskId,
                                description: data.task_description || data.message || 'Processing...',
                                recipient: data.recipient || data.agent,
                                requestor: data.requestor || 'System',
                                status: 'in-progress',
                                created_at: message.timestamp,
                                message: data.message,
                                full_content: data
                            });
                        }
                        break;
                    case 'task_completed':
                    case 'response_generated':
                        const completedTaskId = data.task_id || data.message_id || this.findTaskByDescription(data.task_description || data.message);
                        const responseContent = data.result || data.response || data.output;
                        
                        if (this.tasks.has(completedTaskId)) {
                            this.tasks.get(completedTaskId).status = 'completed';
                            this.tasks.get(completedTaskId).result = responseContent;
                        } else {
                            // Create completed task if it doesn't exist
                            this.tasks.set(completedTaskId, {
                                id: completedTaskId,
                                description: data.task_description || data.message || 'Task completed',
                                recipient: data.recipient || data.agent,
                                requestor: data.requestor || 'System',
                                status: 'completed',
                                created_at: message.timestamp,
                                result: responseContent,
                                message: data.message,
                                full_content: data
                            });
                        }
                        
                        // Check if this looks like a comprehensive final output
                        if (responseContent && responseContent.length > 500 && 
                            (data.agent === 'TeamLeader' || 
                             responseContent.toLowerCase().includes('recommendation') ||
                             responseContent.toLowerCase().includes('analysis') ||
                             responseContent.toLowerCase().includes('conclusion') ||
                             responseContent.toLowerCase().includes('summary'))) {
                            
                            // Add as potential final output
                            this.finalOutputs.push({
                                id: Date.now(),
                                timestamp: message.timestamp,
                                result: responseContent,
                                team_name: data.agent || 'Agent Team',
                                summary: `Comprehensive response from ${data.agent || 'agent'}`,
                                full_data: data
                            });
                            this.updateFinalOutputSection();
                        }
                        break;
                }
                
                this.updateTasksList();
            }

            handleTeamEvent(message) {
                const { event_type, data } = message;
                console.log('Team event:', event_type, data);
                
                switch (event_type) {
                    case 'processing_completed':
                    case 'team_completed':
                    case 'final_result':
                        // Add to final outputs
                        this.finalOutputs.push({
                            id: Date.now(),
                            timestamp: message.timestamp,
                            result: data.result || data.final_result || data.output,
                            team_name: data.team_name || 'Agent Team',
                            summary: data.summary || '',
                            full_data: data
                        });
                        this.updateFinalOutputSection();
                        break;
                    case 'processing_started':
                        // Clear previous outputs when new processing starts
                        this.finalOutputs = [];
                        this.updateFinalOutputSection();
                        break;
                }
            }

            handleProgress(message) {
                const { data } = message;
                console.log('Progress update:', data);
            }

            findTaskByDescription(description) {
                for (const [id, task] of this.tasks) {
                    if (task.description === description) {
                        return id;
                    }
                }
                return Date.now(); // Fallback ID
            }

            updateConnectionStatus(connected) {
                const statusIndicator = document.getElementById('connectionStatus');
                const connectionText = document.getElementById('connectionText');
                
                if (connected) {
                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'Connected';
                } else {
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'Disconnected';
                }
            }

            updateAgentsList() {
                const agentsList = document.getElementById('agentsList');
                agentsList.innerHTML = '';
                
                for (const [name, agent] of this.agents) {
                    const agentCard = document.createElement('div');
                    agentCard.className = `agent-card ${agent.status}`;
                    
                    const statusEmoji = agent.status === 'working' ? '⚡' : 
                                      agent.status === 'idle' ? '💤' : '🤖';
                    
                    agentCard.innerHTML = `
                        <strong>${statusEmoji} ${agent.name}</strong>
                        <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                            Status: ${agent.status}
                        </div>
                        ${agent.current_task ? `
                            <div style="font-size: 0.8em; color: #888; margin-top: 3px;">
                                Task: ${agent.current_task.substring(0, 100)}...
                            </div>
                        ` : ''}
                    `;
                    
                    agentsList.appendChild(agentCard);
                }
            }

            updateTasksList() {
                const tasksList = document.getElementById('tasksList');
                tasksList.innerHTML = '';
                
                // Show only pending and in-progress tasks
                const activeTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'pending' || task.status === 'in-progress')
                    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                if (activeTasks.length === 0) {
                    tasksList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No active tasks</div>';
                    return;
                }
                
                for (const task of activeTasks) {
                    const taskItem = document.createElement('div');
                    taskItem.className = `task-item ${task.status}`;
                    
                    const statusEmoji = task.status === 'completed' ? '✅' :
                                       task.status === 'in-progress' ? '⏳' : '⏸️';
                    
                    taskItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${statusEmoji} ${task.recipient || 'Unknown Agent'}</strong>
                            <span style="font-size: 0.8em; color: #666;">${task.status.replace('-', ' ')}</span>
                        </div>
                        <div style="font-size: 0.9em; margin-top: 5px; background: #f8f9fa; padding: 8px; border-radius: 4px; white-space: pre-wrap;">
                            ${task.description || task.message || 'No description available'}
                        </div>
                        ${task.requestor ? `
                            <div style="font-size: 0.8em; color: #888; margin-top: 3px;">
                                From: ${task.requestor}
                            </div>
                        ` : ''}
                        ${task.result ? `
                            <div style="font-size: 0.8em; color: #27ae60; margin-top: 5px; background: #e8f5e8; padding: 5px; border-radius: 3px;">
                                Result: ${task.result.substring(0, 200)}${task.result.length > 200 ? '...' : ''}
                            </div>
                        ` : ''}
                    `;
                    
                    tasksList.appendChild(taskItem);
                }
            }

            updateMetrics() {
                this.metrics.activeAgents = Array.from(this.agents.values())
                    .filter(agent => agent.status === 'working').length;
                
                this.metrics.completedTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'completed').length;
                
                this.metrics.pendingTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'pending').length;
                
                document.getElementById('activeAgents').textContent = this.metrics.activeAgents;
                document.getElementById('completedTasks').textContent = this.metrics.completedTasks;
                document.getElementById('pendingTasks').textContent = this.metrics.pendingTasks;
            }

            updateFinalOutputSection() {
                const finalOutputSection = document.getElementById('finalOutputSection');
                
                if (this.finalOutputs.length === 0) {
                    finalOutputSection.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No final output yet</div>';
                    return;
                }

                finalOutputSection.innerHTML = '';
                
                // Show most recent output first
                const sortedOutputs = [...this.finalOutputs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                for (const output of sortedOutputs) {
                    const outputCard = document.createElement('div');
                    outputCard.className = 'output-card';
                    outputCard.style.cssText = `
                        background: #f8f9fa;
                        border: 2px solid #28a745;
                        border-radius: 8px;
                        padding: 15px;
                        margin-bottom: 15px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    `;
                    
                    const timestamp = new Date(output.timestamp).toLocaleString();
                    
                    outputCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="color: #28a745;">🎯 ${output.team_name} - Final Result</strong>
                            <span style="font-size: 0.8em; color: #666;">${timestamp}</span>
                        </div>
                        ${output.summary ? `
                            <div style="font-size: 0.9em; color: #495057; margin-bottom: 10px; font-style: italic;">
                                ${output.summary}
                            </div>
                        ` : ''}
                        <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #28a745; white-space: pre-wrap; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.5;">
                            ${output.result || 'No result content available'}
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                            <small style="color: #6c757d;">
                                💡 This represents the comprehensive analysis and recommendations from the agent team.
                            </small>
                        </div>
                    `;
                    
                    finalOutputSection.appendChild(outputCard);
                }
            }

            addToActivityLog(message) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                const logType = message.type.replace('_', ' ');
                
                logEntry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-type ${message.type.split('_')[0]}">${logType}</span>
                    <span>${this.formatLogMessage(message)}</span>
                `;
                
                const activityLog = document.getElementById('activityLog');
                activityLog.insertBefore(logEntry, activityLog.firstChild);
                
                // Keep only last 50 entries
                while (activityLog.children.length > 50) {
                    activityLog.removeChild(activityLog.lastChild);
                }
            }

            formatLogMessage(message) {
                const data = message.data || {};
                
                switch (message.type) {
                    case 'agent_event':
                        switch (message.event_type) {
                            case 'agent_created':
                                return `Agent created: ${data.agent_name} (${data.model || 'Unknown model'})`;
                            case 'agent_started_task':
                                return `${data.agent_name} started: "${(data.task_description || '').substring(0, 100)}..."`;
                            case 'agent_completed_task':
                                return `${data.agent_name} completed task${data.result ? ': "' + data.result.substring(0, 100) + '..."' : ''}`;
                            default:
                                return `${message.event_type}: ${data.agent_name || 'Unknown Agent'}`;
                        }
                    case 'task_event':
                        switch (message.event_type) {
                            case 'task_created':
                            case 'message_sent':
                                return `📤 ${data.requestor || data.from || 'Unknown'} → ${data.recipient || data.to || 'Unknown'}: "${(data.message || data.task_description || '').substring(0, 150)}..."`;
                            case 'task_started':
                            case 'message_processing':
                                return `⚡ Processing: "${(data.message || data.task_description || '').substring(0, 100)}..."`;
                            case 'task_completed':
                            case 'response_generated':
                                return `✅ Response: "${(data.result || data.response || data.output || '').substring(0, 150)}..."`;
                            default:
                                return `${message.event_type}: ${data.recipient || 'Unknown'}`;
                        }
                    case 'team_event':
                        return `Team ${message.event_type}: ${data.team_name || 'Agent Team'}${data.message ? ' - ' + data.message.substring(0, 100) : ''}`;
                    case 'connection':
                        return `Connected to session ${message.session_id}`;
                    default:
                        // Show full data for debugging
                        return `${message.type}: ${JSON.stringify(data).substring(0, 200)}${JSON.stringify(data).length > 200 ? '...' : ''}`;
                }
            }

            setupUI() {
                // Initialize empty states
                this.updateAgentsList();
                this.updateTasksList();
                this.updateFinalOutputSection();
                this.updateMetrics();
            }

            setupQueryInterface() {
                const queryForm = document.getElementById('queryForm');
                const submitBtn = document.getElementById('submitQuery');
                const cancelBtn = document.getElementById('cancelQuery');
                
                queryForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.submitQuery();
                });
                
                cancelBtn.addEventListener('click', () => {
                    this.cancelQuery();
                });
            }

            async submitQuery() {
                const endpoint = document.getElementById('endpoint').value.trim();
                const bearerToken = document.getElementById('bearerToken').value.trim();
                const queryText = document.getElementById('queryText').value.trim();
                const graphQueryType = document.getElementById('graphQueryType').value;
                const searchQueryType = document.getElementById('searchQueryType').value;
                const timeoutMinutes = parseInt(document.getElementById('timeoutMinutes').value);
                const useSearch = document.getElementById('useSearch').checked;
                const useGraph = document.getElementById('useGraph').checked;
                const useWeb = document.getElementById('useWeb').checked;
                const useReasoning = document.getElementById('useReasoning').checked;

                // Validation
                if (!endpoint) {
                    alert('Please enter an API endpoint');
                    return;
                }

                if (!queryText) {
                    alert('Please enter a query');
                    return;
                }

                if (timeoutMinutes <= 0) {
                    alert('Please enter a valid timeout value');
                    return;
                }

                // Clear previous results
                this.clearQueryResponse();
                this.clearVisualizationData();

                // Update UI state
                this.setQueryInProgress(true);
                this.requestCancelled = false;
                this.requestStartTime = Date.now();
                this.updateProgressTimer();

                try {
                    // Prepare request data
                    const requestData = {
                        query: queryText,
                        graph_query_type: graphQueryType,
                        search_query_type: searchQueryType,
                        use_search: useSearch,
                        use_graph: useGraph,
                        use_web: useWeb,
                        use_reasoning: useReasoning
                    };

                    // Prepare headers
                    const headers = {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    };

                    if (bearerToken) {
                        headers['Authorization'] = `Bearer ${bearerToken}`;
                    }

                    // Make the request
                    const controller = new AbortController();
                    this.currentRequest = controller;

                    const timeoutMs = timeoutMinutes * 60 * 1000;
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestData),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (this.requestCancelled) {
                        return;
                    }

                    await this.handleQueryResponse(response);

                } catch (error) {
                    if (!this.requestCancelled) {
                        if (error.name === 'AbortError') {
                            this.handleQueryError('Request timed out or was cancelled');
                        } else {
                            this.handleQueryError(`Request failed: ${error.message}`);
                        }
                    }
                } finally {
                    this.setQueryInProgress(false);
                    this.currentRequest = null;
                }
            }

            async handleQueryResponse(response) {
                try {
                    if (response.ok) {
                        const contentType = response.headers.get('content-type');
                        
                        if (contentType && contentType.includes('application/json')) {
                            const data = await response.json();
                            this.displayQueryResponse(data);
                        } else {
                            const text = await response.text();
                            this.displayQueryResponse(text);
                        }
                    } else {
                        const errorText = await response.text();
                        this.handleQueryError(`Server error ${response.status}: ${errorText}`);
                    }
                } catch (error) {
                    this.handleQueryError(`Failed to process response: ${error.message}`);
                }
            }

            displayQueryResponse(data) {
                const responseContainer = document.getElementById('queryResponse');
                
                if (typeof data === 'string') {
                    // Handle markdown/text response
                    responseContainer.innerHTML = this.renderMarkdown(data);
                } else if (typeof data === 'object') {
                    // Handle JSON response
                    if (data.content || data.response || data.message || data.text) {
                        const content = data.content || data.response || data.message || data.text;
                        responseContainer.innerHTML = this.renderMarkdown(content);
                    } else {
                        // Display formatted JSON
                        responseContainer.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                    }
                } else {
                    responseContainer.innerHTML = `<pre>${String(data)}</pre>`;
                }
            }

            renderMarkdown(text) {
                // Simple markdown renderer for HTML
                return text
                    .replace(/### (.*)/g, '<h3>$1</h3>')
                    .replace(/## (.*)/g, '<h2>$1</h2>')
                    .replace(/# (.*)/g, '<h1>$1</h1>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>')
                    .replace(/```([\s\S]*?)```/g, '<pre>$1</pre>')
                    .replace(/^\- (.*)/gm, '<li>$1</li>')
                    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                    .replace(/^\d+\. (.*)/gm, '<li>$1</li>')
                    .replace(/\n/g, '<br>');
            }

            handleQueryError(errorMessage) {
                const responseContainer = document.getElementById('queryResponse');
                responseContainer.innerHTML = `
                    <div style="color: #e74c3c; padding: 20px; background: #fdf2f2; border-radius: 6px; border: 1px solid #f5c6cb;">
                        <strong>Error:</strong> ${errorMessage}
                    </div>
                `;
            }

            cancelQuery() {
                this.requestCancelled = true;
                if (this.currentRequest) {
                    this.currentRequest.abort();
                }
                this.setQueryInProgress(false);
                this.handleQueryError('Request was cancelled by user');
            }

            setQueryInProgress(inProgress) {
                const submitBtn = document.getElementById('submitQuery');
                const cancelBtn = document.getElementById('cancelQuery');
                const progressBar = document.getElementById('progressBar');

                if (inProgress) {
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Processing...';
                    cancelBtn.style.display = 'inline-block';
                    progressBar.style.display = 'block';
                } else {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Query';
                    cancelBtn.style.display = 'none';
                    progressBar.style.display = 'none';
                    document.getElementById('progressText').textContent = '';
                }
            }

            updateProgressTimer() {
                if (!this.requestStartTime || this.requestCancelled) {
                    return;
                }

                const elapsed = Date.now() - this.requestStartTime;
                const seconds = Math.floor(elapsed / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;

                const timeStr = minutes > 0 ? `${minutes}m ${remainingSeconds}s` : `${remainingSeconds}s`;
                document.getElementById('progressText').textContent = `Elapsed: ${timeStr}`;

                if (!this.requestCancelled && this.currentRequest) {
                    setTimeout(() => this.updateProgressTimer(), 1000);
                }
            }

            clearQueryResponse() {
                const responseContainer = document.getElementById('queryResponse');
                responseContainer.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px;">
                        Processing query... Watch the real-time progress below.
                    </div>
                `;
            }

            clearVisualizationData() {
                // Clear previous visualization data when new query starts
                this.agents.clear();
                this.tasks.clear();
                this.finalOutputs = [];
                this.activityLog = [];
                
                // Update all sections
                this.updateAgentsList();
                this.updateTasksList();
                this.updateFinalOutputSection();
                this.updateMetrics();
                
                // Clear activity log
                document.getElementById('activityLog').innerHTML = '';
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AgentTeamVisualizer();
        });
    </script>
</body>
</html>
