<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Team Real-time Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            min-height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .status-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            height: fit-content;
        }

        .visualization-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            display: flex;
            flex-direction: column;
        }

        .activity-log {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-height: 300px;
            overflow-y: auto;
        }

        h1, h2, h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #27ae60;
        }

        .agent-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #3498db;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .agent-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .agent-card.active {
            border-left-color: #27ae60;
            background: #e8f5e8;
        }

        .agent-card.working {
            border-left-color: #f39c12;
            background: #fef9e7;
            animation: working 1.5s infinite;
        }

        .task-item {
            background: #fff;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #9b59b6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .task-item.completed {
            border-left-color: #27ae60;
            background: #f0f8f0;
        }

        .task-item.in-progress {
            border-left-color: #f39c12;
            background: #fefcf0;
        }

        .log-entry {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            font-size: 0.8em;
            color: #7f8c8d;
            min-width: 80px;
        }

        .log-type {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .log-type.agent {
            background: #3498db;
            color: white;
        }

        .log-type.task {
            background: #9b59b6;
            color: white;
        }

        .log-type.team {
            background: #27ae60;
            color: white;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes working {
            0% { background: #fef9e7; }
            50% { background: #fcf3cf; }
            100% { background: #fef9e7; }
        }

        .scrollable {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Custom scrollbar */
        .scrollable::-webkit-scrollbar {
            width: 6px;
        }

        .scrollable::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Agent Team Real-time Visualization</h1>
            <div class="connection-status">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
                <span id="sessionInfo"></span>
            </div>
        </div>

        <div class="status-panel">
            <h3>üìä Team Status</h3>
            <div id="teamMetrics" class="metrics">
                <div class="metric">
                    <div class="metric-value" id="activeAgents">0</div>
                    <div class="metric-label">Active Agents</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="completedTasks">0</div>
                    <div class="metric-label">Completed Tasks</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="pendingTasks">0</div>
                    <div class="metric-label">Pending Tasks</div>
                </div>
            </div>

            <h3 style="margin-top: 25px;">ü§ñ Agents</h3>
            <div id="agentsList" class="scrollable"></div>
        </div>

        <div class="visualization-panel">
            <h3>üìã Current Tasks</h3>
            <div id="tasksList" class="scrollable"></div>
        </div>

        <div class="visualization-panel">
            <h3>üéØ Final Output</h3>
            <div id="finalOutputSection" class="scrollable">
                <div style="text-align: center; color: #666; padding: 20px;">
                    No final output yet
                </div>
            </div>
        </div>

        <div class="activity-log">
            <h3>üìù Activity Log</h3>
            <div id="activityLog" class="scrollable"></div>
        </div>
    </div>

    <script>
        class AgentTeamVisualizer {
            constructor() {
                this.socket = null;
                this.sessionId = this.generateSessionId();
                this.agents = new Map();
                this.tasks = new Map();
                this.activityLog = [];
                this.finalOutputs = [];
                this.metrics = {
                    activeAgents: 0,
                    completedTasks: 0,
                    pendingTasks: 0
                };
                
                this.connect();
                this.setupUI();
            }

            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/${this.sessionId}`;
                
                this.socket = new WebSocket(wsUrl);
                
                this.socket.onopen = () => {
                    console.log('WebSocket connected');
                    this.updateConnectionStatus(true);
                };
                
                this.socket.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
                
                this.socket.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.updateConnectionStatus(false);
                    
                    // Attempt to reconnect after 3 seconds
                    setTimeout(() => {
                        if (this.socket.readyState === WebSocket.CLOSED) {
                            this.connect();
                        }
                    }, 3000);
                };
                
                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };
            }

            handleMessage(message) {
                console.log('Received message:', message);
                
                switch (message.type) {
                    case 'connection':
                        this.handleConnection(message);
                        break;
                    case 'agent_event':
                        this.handleAgentEvent(message);
                        break;
                    case 'task_event':
                        this.handleTaskEvent(message);
                        break;
                    case 'team_event':
                        this.handleTeamEvent(message);
                        break;
                    case 'progress':
                        this.handleProgress(message);
                        break;
                }
                
                this.addToActivityLog(message);
                this.updateMetrics();
            }

            handleConnection(message) {
                document.getElementById('sessionInfo').textContent = `Session: ${message.session_id}`;
            }

            handleAgentEvent(message) {
                const { event_type, data } = message;
                
                switch (event_type) {
                    case 'agent_created':
                        this.agents.set(data.agent_name, {
                            name: data.agent_name,
                            status: 'idle',
                            model: data.model || 'Unknown',
                            instructions: data.instructions || '',
                            current_task: null
                        });
                        break;
                    case 'agent_started_task':
                        if (this.agents.has(data.agent_name)) {
                            this.agents.get(data.agent_name).status = 'working';
                            this.agents.get(data.agent_name).current_task = data.task_description;
                        }
                        break;
                    case 'agent_completed_task':
                        if (this.agents.has(data.agent_name)) {
                            this.agents.get(data.agent_name).status = 'idle';
                            this.agents.get(data.agent_name).current_task = null;
                        }
                        break;
                }
                
                this.updateAgentsList();
            }

            handleTaskEvent(message) {
                const { event_type, data } = message;
                
                switch (event_type) {
                    case 'task_created':
                    case 'message_sent':
                        const taskId = data.task_id || data.message_id || Date.now();
                        this.tasks.set(taskId, {
                            id: taskId,
                            description: data.task_description || data.message || data.content,
                            recipient: data.recipient || data.to,
                            requestor: data.requestor || data.from,
                            status: 'pending',
                            created_at: message.timestamp,
                            message: data.message || data.content,
                            full_content: data
                        });
                        break;
                    case 'task_started':
                    case 'message_processing':
                        const startedTaskId = data.task_id || data.message_id || this.findTaskByDescription(data.task_description || data.message);
                        if (this.tasks.has(startedTaskId)) {
                            this.tasks.get(startedTaskId).status = 'in-progress';
                        } else {
                            // Create task if it doesn't exist
                            this.tasks.set(startedTaskId, {
                                id: startedTaskId,
                                description: data.task_description || data.message || 'Processing...',
                                recipient: data.recipient || data.agent,
                                requestor: data.requestor || 'System',
                                status: 'in-progress',
                                created_at: message.timestamp,
                                message: data.message,
                                full_content: data
                            });
                        }
                        break;
                    case 'task_completed':
                    case 'response_generated':
                        const completedTaskId = data.task_id || data.message_id || this.findTaskByDescription(data.task_description || data.message);
                        const responseContent = data.result || data.response || data.output;
                        
                        if (this.tasks.has(completedTaskId)) {
                            this.tasks.get(completedTaskId).status = 'completed';
                            this.tasks.get(completedTaskId).result = responseContent;
                        } else {
                            // Create completed task if it doesn't exist
                            this.tasks.set(completedTaskId, {
                                id: completedTaskId,
                                description: data.task_description || data.message || 'Task completed',
                                recipient: data.recipient || data.agent,
                                requestor: data.requestor || 'System',
                                status: 'completed',
                                created_at: message.timestamp,
                                result: responseContent,
                                message: data.message,
                                full_content: data
                            });
                        }
                        
                        // Check if this looks like a comprehensive final output
                        if (responseContent && responseContent.length > 500 && 
                            (data.agent === 'TeamLeader' || 
                             responseContent.toLowerCase().includes('recommendation') ||
                             responseContent.toLowerCase().includes('analysis') ||
                             responseContent.toLowerCase().includes('conclusion') ||
                             responseContent.toLowerCase().includes('summary'))) {
                            
                            // Add as potential final output
                            this.finalOutputs.push({
                                id: Date.now(),
                                timestamp: message.timestamp,
                                result: responseContent,
                                team_name: data.agent || 'Agent Team',
                                summary: `Comprehensive response from ${data.agent || 'agent'}`,
                                full_data: data
                            });
                            this.updateFinalOutputSection();
                        }
                        break;
                }
                
                this.updateTasksList();
            }

            handleTeamEvent(message) {
                const { event_type, data } = message;
                console.log('Team event:', event_type, data);
                
                switch (event_type) {
                    case 'processing_completed':
                    case 'team_completed':
                    case 'final_result':
                        // Add to final outputs
                        this.finalOutputs.push({
                            id: Date.now(),
                            timestamp: message.timestamp,
                            result: data.result || data.final_result || data.output,
                            team_name: data.team_name || 'Agent Team',
                            summary: data.summary || '',
                            full_data: data
                        });
                        this.updateFinalOutputSection();
                        break;
                    case 'processing_started':
                        // Clear previous outputs when new processing starts
                        this.finalOutputs = [];
                        this.updateFinalOutputSection();
                        break;
                }
            }

            handleProgress(message) {
                const { data } = message;
                console.log('Progress update:', data);
            }

            findTaskByDescription(description) {
                for (const [id, task] of this.tasks) {
                    if (task.description === description) {
                        return id;
                    }
                }
                return Date.now(); // Fallback ID
            }

            updateConnectionStatus(connected) {
                const statusIndicator = document.getElementById('connectionStatus');
                const connectionText = document.getElementById('connectionText');
                
                if (connected) {
                    statusIndicator.classList.add('connected');
                    connectionText.textContent = 'Connected';
                } else {
                    statusIndicator.classList.remove('connected');
                    connectionText.textContent = 'Disconnected';
                }
            }

            updateAgentsList() {
                const agentsList = document.getElementById('agentsList');
                agentsList.innerHTML = '';
                
                for (const [name, agent] of this.agents) {
                    const agentCard = document.createElement('div');
                    agentCard.className = `agent-card ${agent.status}`;
                    
                    const statusEmoji = agent.status === 'working' ? '‚ö°' : 
                                      agent.status === 'idle' ? 'üí§' : 'ü§ñ';
                    
                    agentCard.innerHTML = `
                        <strong>${statusEmoji} ${agent.name}</strong>
                        <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                            Status: ${agent.status}
                        </div>
                        ${agent.current_task ? `
                            <div style="font-size: 0.8em; color: #888; margin-top: 3px;">
                                Task: ${agent.current_task.substring(0, 100)}...
                            </div>
                        ` : ''}
                    `;
                    
                    agentsList.appendChild(agentCard);
                }
            }

            updateTasksList() {
                const tasksList = document.getElementById('tasksList');
                tasksList.innerHTML = '';
                
                // Show only pending and in-progress tasks
                const activeTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'pending' || task.status === 'in-progress')
                    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                if (activeTasks.length === 0) {
                    tasksList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No active tasks</div>';
                    return;
                }
                
                for (const task of activeTasks) {
                    const taskItem = document.createElement('div');
                    taskItem.className = `task-item ${task.status}`;
                    
                    const statusEmoji = task.status === 'completed' ? '‚úÖ' :
                                       task.status === 'in-progress' ? '‚è≥' : '‚è∏Ô∏è';
                    
                    taskItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${statusEmoji} ${task.recipient || 'Unknown Agent'}</strong>
                            <span style="font-size: 0.8em; color: #666;">${task.status.replace('-', ' ')}</span>
                        </div>
                        <div style="font-size: 0.9em; margin-top: 5px; background: #f8f9fa; padding: 8px; border-radius: 4px; white-space: pre-wrap;">
                            ${task.description || task.message || 'No description available'}
                        </div>
                        ${task.requestor ? `
                            <div style="font-size: 0.8em; color: #888; margin-top: 3px;">
                                From: ${task.requestor}
                            </div>
                        ` : ''}
                        ${task.result ? `
                            <div style="font-size: 0.8em; color: #27ae60; margin-top: 5px; background: #e8f5e8; padding: 5px; border-radius: 3px;">
                                Result: ${task.result.substring(0, 200)}${task.result.length > 200 ? '...' : ''}
                            </div>
                        ` : ''}
                    `;
                    
                    tasksList.appendChild(taskItem);
                }
            }

            updateMetrics() {
                this.metrics.activeAgents = Array.from(this.agents.values())
                    .filter(agent => agent.status === 'working').length;
                
                this.metrics.completedTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'completed').length;
                
                this.metrics.pendingTasks = Array.from(this.tasks.values())
                    .filter(task => task.status === 'pending').length;
                
                document.getElementById('activeAgents').textContent = this.metrics.activeAgents;
                document.getElementById('completedTasks').textContent = this.metrics.completedTasks;
                document.getElementById('pendingTasks').textContent = this.metrics.pendingTasks;
            }

            updateFinalOutputSection() {
                const finalOutputSection = document.getElementById('finalOutputSection');
                
                if (this.finalOutputs.length === 0) {
                    finalOutputSection.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No final output yet</div>';
                    return;
                }

                finalOutputSection.innerHTML = '';
                
                // Show most recent output first
                const sortedOutputs = [...this.finalOutputs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                for (const output of sortedOutputs) {
                    const outputCard = document.createElement('div');
                    outputCard.className = 'output-card';
                    outputCard.style.cssText = `
                        background: #f8f9fa;
                        border: 2px solid #28a745;
                        border-radius: 8px;
                        padding: 15px;
                        margin-bottom: 15px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    `;
                    
                    const timestamp = new Date(output.timestamp).toLocaleString();
                    
                    outputCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="color: #28a745;">üéØ ${output.team_name} - Final Result</strong>
                            <span style="font-size: 0.8em; color: #666;">${timestamp}</span>
                        </div>
                        ${output.summary ? `
                            <div style="font-size: 0.9em; color: #495057; margin-bottom: 10px; font-style: italic;">
                                ${output.summary}
                            </div>
                        ` : ''}
                        <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid #28a745; white-space: pre-wrap; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.5;">
                            ${output.result || 'No result content available'}
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                            <small style="color: #6c757d;">
                                üí° This represents the comprehensive analysis and recommendations from the agent team.
                            </small>
                        </div>
                    `;
                    
                    finalOutputSection.appendChild(outputCard);
                }
            }

            addToActivityLog(message) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                const logType = message.type.replace('_', ' ');
                
                logEntry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-type ${message.type.split('_')[0]}">${logType}</span>
                    <span>${this.formatLogMessage(message)}</span>
                `;
                
                const activityLog = document.getElementById('activityLog');
                activityLog.insertBefore(logEntry, activityLog.firstChild);
                
                // Keep only last 50 entries
                while (activityLog.children.length > 50) {
                    activityLog.removeChild(activityLog.lastChild);
                }
            }

            formatLogMessage(message) {
                const data = message.data || {};
                
                switch (message.type) {
                    case 'agent_event':
                        switch (message.event_type) {
                            case 'agent_created':
                                return `Agent created: ${data.agent_name} (${data.model || 'Unknown model'})`;
                            case 'agent_started_task':
                                return `${data.agent_name} started: "${(data.task_description || '').substring(0, 100)}..."`;
                            case 'agent_completed_task':
                                return `${data.agent_name} completed task${data.result ? ': "' + data.result.substring(0, 100) + '..."' : ''}`;
                            default:
                                return `${message.event_type}: ${data.agent_name || 'Unknown Agent'}`;
                        }
                    case 'task_event':
                        switch (message.event_type) {
                            case 'task_created':
                            case 'message_sent':
                                return `üì§ ${data.requestor || data.from || 'Unknown'} ‚Üí ${data.recipient || data.to || 'Unknown'}: "${(data.message || data.task_description || '').substring(0, 150)}..."`;
                            case 'task_started':
                            case 'message_processing':
                                return `‚ö° Processing: "${(data.message || data.task_description || '').substring(0, 100)}..."`;
                            case 'task_completed':
                            case 'response_generated':
                                return `‚úÖ Response: "${(data.result || data.response || data.output || '').substring(0, 150)}..."`;
                            default:
                                return `${message.event_type}: ${data.recipient || 'Unknown'}`;
                        }
                    case 'team_event':
                        return `Team ${message.event_type}: ${data.team_name || 'Agent Team'}${data.message ? ' - ' + data.message.substring(0, 100) : ''}`;
                    case 'connection':
                        return `Connected to session ${message.session_id}`;
                    default:
                        // Show full data for debugging
                        return `${message.type}: ${JSON.stringify(data).substring(0, 200)}${JSON.stringify(data).length > 200 ? '...' : ''}`;
                }
            }

            setupUI() {
                // Initialize empty states
                this.updateAgentsList();
                this.updateTasksList();
                this.updateFinalOutputSection();
                this.updateMetrics();
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AgentTeamVisualizer();
        });
    </script>
</body>
</html>
